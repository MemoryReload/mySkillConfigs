{
  "title": "Define a hook callback that receives tool call details",
  "content": "async def protect_env_files(input_data, tool_use_id, context):\n    # Extract the file path from the tool's input arguments\n    file_path = input_data['tool_input'].get('file_path', '')\n    file_name = file_path.split('/')[-1]\n\n# Block the operation if targeting a .env file\n    if file_name == '.env':\n        return {\n            'hookSpecificOutput': {\n                'hookEventName': input_data['hook_event_name'],\n                'permissionDecision': 'deny',\n                'permissionDecisionReason': 'Cannot modify .env files'\n            }\n        }\n\n# Return empty object to allow the operation\n    return {}\n\nasync def main():\n    async for message in query(\n        prompt=\"Update the database configuration\",\n        options=ClaudeAgentOptions(\n            hooks={\n                # Register the hook for PreToolUse events\n                # The matcher filters to only Write and Edit tool calls\n                'PreToolUse': [HookMatcher(matcher='Write|Edit', hooks=[protect_env_files])]\n            }\n        )\n    ):\n        print(message)\n\nasyncio.run(main())\ntypescript TypeScript\nimport { query, HookCallback, PreToolUseHookInput } from \"@anthropic-ai/claude-agent-sdk\";\n\n// Define a hook callback with the HookCallback type\nconst protectEnvFiles: HookCallback = async (input, toolUseID, { signal }) => {\n  // Cast input to the specific hook type for type safety\n  const preInput = input as PreToolUseHookInput;\n\n// Extract the file path from the tool's input arguments\n  const filePath = preInput.tool_input?.file_path as string;\n  const fileName = filePath?.split('/').pop();\n\n// Block the operation if targeting a .env file\n  if (fileName === '.env') {\n    return {\n      hookSpecificOutput: {\n        hookEventName: input.hook_event_name,\n        permissionDecision: 'deny',\n        permissionDecisionReason: 'Cannot modify .env files'\n      }\n    };\n  }\n\n// Return empty object to allow the operation\n  return {};\n};\n\nfor await (const message of query({\n  prompt: \"Update the database configuration\",\n  options: {\n    hooks: {\n      // Register the hook for PreToolUse events\n      // The matcher filters to only Write and Edit tool calls\n      PreToolUse: [{ matcher: 'Write|Edit', hooks: [protectEnvFiles] }]\n    }\n  }\n})) {\n  console.log(message);\n}\npython Python\nasync for message in query(\n    prompt=\"Your prompt\",\n    options=ClaudeAgentOptions(\n        hooks={\n            'PreToolUse': [HookMatcher(matcher='Bash', hooks=[my_callback])]\n        }\n    )\n):\n    print(message)\ntypescript TypeScript\nfor await (const message of query({\n  prompt: \"Your prompt\",\n  options: {\n    hooks: {\n      PreToolUse: [{ matcher: 'Bash', hooks: [myCallback] }]\n    }\n  }\n})) {\n  console.log(message);\n}\npython Python\noptions = ClaudeAgentOptions(\n    hooks={\n        'PreToolUse': [\n            HookMatcher(matcher='Write|Edit', hooks=[validate_file_path])\n        ]\n    }\n)\ntypescript TypeScript\nconst options = {\n  hooks: {\n    PreToolUse: [\n      { matcher: 'Write|Edit', hooks: [validateFilePath] }\n    ]\n  }\n};\npython Python\nasync def log_tool_calls(input_data, tool_use_id, context):\n    if input_data['hook_event_name'] == 'PreToolUse':\n        print(f\"Tool: {input_data['tool_name']}\")\n        print(f\"Input: {input_data['tool_input']}\")\n    return {}\ntypescript TypeScript\nconst logToolCalls: HookCallback = async (input, toolUseID, { signal }) => {\n  if (input.hook_event_name === 'PreToolUse') {\n    const preInput = input as PreToolUseHookInput;\n    console.log(`Tool: ${preInput.tool_name}`);\n    console.log(`Input:`, preInput.tool_input);\n  }\n  return {};\n};\npython Python\nasync def block_etc_writes(input_data, tool_use_id, context):\n    file_path = input_data['tool_input'].get('file_path', '')\n\nif file_path.startswith('/etc'):\n        return {\n            # Top-level field: inject guidance into the conversation\n            'systemMessage': 'Remember: system directories like /etc are protected.',\n            # hookSpecificOutput: block the operation\n            'hookSpecificOutput': {\n                'hookEventName': input_data['hook_event_name'],\n                'permissionDecision': 'deny',\n                'permissionDecisionReason': 'Writing to /etc is not allowed'\n            }\n        }\n    return {}\ntypescript TypeScript\nconst blockEtcWrites: HookCallback = async (input, toolUseID, { signal }) => {\n  const filePath = (input as PreToolUseHookInput).tool_input?.file_path as string;\n\nif (filePath?.startsWith('/etc')) {\n    return {\n      // Top-level field: inject guidance into the conversation\n      systemMessage: 'Remember: system directories like /etc are protected.',\n      // hookSpecificOutput: block the operation\n      hookSpecificOutput: {\n        hookEventName: input.hook_event_name,\n        permissionDecision: 'deny',\n        permissionDecisionReason: 'Writing to /etc is not allowed'\n      }\n    };\n  }\n  return {};\n};\npython Python\nasync def block_dangerous_commands(input_data, tool_use_id, context):\n    if input_data['hook_event_name'] != 'PreToolUse':\n        return {}\n\ncommand = input_data['tool_input'].get('command', '')\n\nif 'rm -rf /' in command:\n        return {\n            'hookSpecificOutput': {\n                'hookEventName': input_data['hook_event_name'],\n                'permissionDecision': 'deny',\n                'permissionDecisionReason': 'Dangerous command blocked: rm -rf /'\n            }\n        }\n    return {}\ntypescript TypeScript\nconst blockDangerousCommands: HookCallback = async (input, toolUseID, { signal }) => {\n  if (input.hook_event_name !== 'PreToolUse') return {};\n\nconst command = (input as PreToolUseHookInput).tool_input.command as string;\n\nif (command?.includes('rm -rf /')) {\n    return {\n      hookSpecificOutput: {\n        hookEventName: input.hook_event_name,\n        permissionDecision: 'deny',\n        permissionDecisionReason: 'Dangerous command blocked: rm -rf /'\n      }\n    };\n  }\n  return {};\n};\npython Python\nasync def redirect_to_sandbox(input_data, tool_use_id, context):\n    if input_data['hook_event_name'] != 'PreToolUse':\n        return {}\n\nif input_data['tool_name'] == 'Write':\n        original_path = input_data['tool_input'].get('file_path', '')\n        return {\n            'hookSpecificOutput': {\n                'hookEventName': input_data['hook_event_name'],\n                'permissionDecision': 'allow',\n                'updatedInput': {\n                    **input_data['tool_input'],\n                    'file_path': f'/sandbox{original_path}'\n                }\n            }\n        }\n    return {}\ntypescript TypeScript\nconst redirectToSandbox: HookCallback = async (input, toolUseID, { signal }) => {\n  if (input.hook_event_name !== 'PreToolUse') return {};\n\nconst preInput = input as PreToolUseHookInput;\n  if (preInput.tool_name === 'Write') {\n    const originalPath = preInput.tool_input.file_path as string;\n    return {\n      hookSpecificOutput: {\n        hookEventName: input.hook_event_name,\n        permissionDecision: 'allow',\n        updatedInput: {\n          ...preInput.tool_input,\n          file_path: `/sandbox${originalPath}`\n        }\n      }\n    };\n  }\n  return {};\n};\npython Python\nasync def add_security_reminder(input_data, tool_use_id, context):\n    return {\n        'systemMessage': 'Remember to follow security best practices.'\n    }\ntypescript TypeScript\nconst addSecurityReminder: HookCallback = async (input, toolUseID, { signal }) => {\n  return {\n    systemMessage: 'Remember to follow security best practices.'\n  };\n};\npython Python\nasync def auto_approve_read_only(input_data, tool_use_id, context):\n    if input_data['hook_event_name'] != 'PreToolUse':\n        return {}\n\nread_only_tools = ['Read', 'Glob', 'Grep', 'LS']\n    if input_data['tool_name'] in read_only_tools:\n        return {\n            'hookSpecificOutput': {\n                'hookEventName': input_data['hook_event_name'],\n                'permissionDecision': 'allow',\n                'permissionDecisionReason': 'Read-only tool auto-approved'\n            }\n        }\n    return {}\ntypescript TypeScript\nconst autoApproveReadOnly: HookCallback = async (input, toolUseID, { signal }) => {\n  if (input.hook_event_name !== 'PreToolUse') return {};\n\nconst preInput = input as PreToolUseHookInput;\n  const readOnlyTools = ['Read', 'Glob', 'Grep', 'LS'];\n  if (readOnlyTools.includes(preInput.tool_name)) {\n    return {\n      hookSpecificOutput: {\n        hookEventName: input.hook_event_name,\n        permissionDecision: 'allow',\n        permissionDecisionReason: 'Read-only tool auto-approved'\n      }\n    };\n  }\n  return {};\n};\npython Python\noptions = ClaudeAgentOptions(\n    hooks={\n        'PreToolUse': [\n            HookMatcher(hooks=[rate_limiter]),        # First: check rate limits\n            HookMatcher(hooks=[authorization_check]), # Second: verify permissions\n            HookMatcher(hooks=[input_sanitizer]),     # Third: sanitize inputs\n            HookMatcher(hooks=[audit_logger])         # Last: log the action\n        ]\n    }\n)\ntypescript TypeScript\nconst options = {\n  hooks: {\n    'PreToolUse': [\n      { hooks: [rateLimiter] },        // First: check rate limits\n      { hooks: [authorizationCheck] }, // Second: verify permissions\n      { hooks: [inputSanitizer] },     // Third: sanitize inputs\n      { hooks: [auditLogger] }         // Last: log the action\n    ]\n  }\n};\npython Python\noptions = ClaudeAgentOptions(\n    hooks={\n        'PreToolUse': [\n            # Match file modification tools\n            HookMatcher(matcher='Write|Edit|Delete', hooks=[file_security_hook]),\n\n# Match all MCP tools\n            HookMatcher(matcher='^mcp__', hooks=[mcp_audit_hook]),\n\n# Match everything (no matcher)\n            HookMatcher(hooks=[global_logger])\n        ]\n    }\n)\ntypescript TypeScript\nconst options = {\n  hooks: {\n    'PreToolUse': [\n      // Match file modification tools\n      { matcher: 'Write|Edit|Delete', hooks: [fileSecurityHook] },\n\n// Match all MCP tools\n      { matcher: '^mcp__', hooks: [mcpAuditHook] },\n\n// Match everything (no matcher)\n      { hooks: [globalLogger] }\n    ]\n  }\n};\npython Python\nasync def subagent_tracker(input_data, tool_use_id, context):\n    if input_data['hook_event_name'] == 'SubagentStop':\n        print(f\"[SUBAGENT] Completed\")\n        print(f\"  Tool use ID: {tool_use_id}\")\n        print(f\"  Stop hook active: {input_data.get('stop_hook_active')}\")\n    return {}\n\noptions = ClaudeAgentOptions(\n    hooks={\n        'SubagentStop': [HookMatcher(hooks=[subagent_tracker])]\n    }\n)\ntypescript TypeScript\nconst subagentTracker: HookCallback = async (input, toolUseID, { signal }) => {\n  if (input.hook_event_name === 'SubagentStop') {\n    console.log(`[SUBAGENT] Completed`);\n    console.log(`  Tool use ID: ${toolUseID}`);\n    console.log(`  Stop hook active: ${input.stop_hook_active}`);\n  }\n  return {};\n};\n\nconst options = {\n  hooks: {\n    SubagentStop: [{ hooks: [subagentTracker] }]\n  }\n};\npython Python\nimport aiohttp\nfrom datetime import datetime\n\nasync def webhook_notifier(input_data, tool_use_id, context):\n    if input_data['hook_event_name'] != 'PostToolUse':\n        return {}\n\ntry:\n        async with aiohttp.ClientSession() as session:\n            await session.post(\n                'https://api.example.com/webhook',\n                json={\n                    'tool': input_data['tool_name'],\n                    'timestamp': datetime.now().isoformat()\n                }\n            )\n    except Exception as e:\n        print(f'Webhook request failed: {e}')\n\nreturn {}\ntypescript TypeScript\nconst webhookNotifier: HookCallback = async (input, toolUseID, { signal }) => {\n  if (input.hook_event_name !== 'PostToolUse') return {};\n\ntry {\n    // Pass signal for proper cancellation\n    await fetch('https://api.example.com/webhook', {\n      method: 'POST',\n      body: JSON.stringify({\n        tool: (input as PostToolUseHookInput).tool_name,\n        timestamp: new Date().toISOString()\n      }),\n      signal\n    });\n  } catch (error) {\n    if (error instanceof Error && error.name === 'AbortError') {\n      console.log('Webhook request cancelled');\n    }\n  }\n\nreturn {};\n};\ntypescript TypeScript\nimport { query, HookCallback, NotificationHookInput } from \"@anthropic-ai/claude-agent-sdk\";\n\nconst notificationHandler: HookCallback = async (input, toolUseID, { signal }) => {\n  const notification = input as NotificationHookInput;\n\nawait fetch('https://hooks.slack.com/services/YOUR/WEBHOOK/URL', {\n    method: 'POST',\n    body: JSON.stringify({\n      text: `Agent status: ${notification.message}`\n    }),\n    signal\n  });\n\nfor await (const message of query({\n  prompt: \"Analyze this codebase\",\n  options: {\n    hooks: {\n      Notification: [{ hooks: [notificationHandler] }]\n    }\n  }\n})) {\n  console.log(message);\n}\ntypescript\nconst myHook: HookCallback = async (input, toolUseID, { signal }) => {\n  const preInput = input as PreToolUseHookInput;\n  const filePath = preInput.tool_input?.file_path as string;\n  if (!filePath?.endsWith('.md')) return {};  // Skip non-markdown files\n  // Process markdown files...\n};\ntypescript\n  return {\n    hookSpecificOutput: {\n      hookEventName: input.hook_event_name,\n      permissionDecision: 'allow',\n      updatedInput: { command: 'new command' }\n    }\n  };\n  ```\n\n- You must also return `permissionDecision: 'allow'` for the input modification to take effect\n- Include `hookEventName` in `hookSpecificOutput` to identify which hook type the output is for\n\n### Session hooks not available\n\n`SessionStart`, `SessionEnd`, and `Notification` hooks are only available in the TypeScript SDK. The Python SDK does not support these events due to setup limitations.\n\n### Subagent permission prompts multiplying\n\nWhen spawning multiple subagents, each one may request permissions separately. Subagents do not automatically inherit parent agent permissions. To avoid repeated prompts, use `PreToolUse` hooks to auto-approve specific tools, or configure permission rules that apply to subagent sessions.\n\n### Recursive hook loops with subagents\n\nA `UserPromptSubmit` hook that spawns subagents can create infinite loops if those subagents trigger the same hook. To prevent this:\n\n- Check for a subagent indicator in the hook input before spawning\n- Use the `parent_tool_use_id` field to detect if you're already in a subagent context\n- Scope hooks to only run for the top-level agent session\n\n### systemMessage not appearing in output\n\nThe `systemMessage` field adds context to the conversation that the model sees, but it may not appear in all SDK output modes. If you need to surface hook decisions to your application, log them separately or use a dedicated output channel.\n\n- [Permissions](/docs/en/agent-sdk/permissions): control what your agent can do\n- [Custom Tools](/docs/en/agent-sdk/custom-tools): build tools to extend agent capabilities\n- [TypeScript SDK Reference](/docs/en/agent-sdk/typescript)\n- [Python SDK Reference](/docs/en/agent-sdk/python)",
  "code_samples": [
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "</CodeGroup>\n\nThis is a `PreToolUse` hook. It runs before the tool executes and can block or allow operations based on your logic. The rest of this guide covers all available hooks, their configuration options, and patterns for common use cases.\n\n## Available hooks\n\nThe SDK provides hooks for different stages of agent execution. Some hooks are available in both SDKs, while others are TypeScript-only because the Python SDK doesn't support them.\n\n| Hook Event | Python SDK | TypeScript SDK | What triggers it | Example use case |\n|------------|------------|----------------|------------------|------------------|\n| `PreToolUse` | Yes | Yes | Tool call request (can block or modify) | Block dangerous shell commands |\n| `PostToolUse` | Yes | Yes | Tool execution result | Log all file changes to audit trail |\n| `PostToolUseFailure` | No | Yes | Tool execution failure | Handle or log tool errors |\n| `UserPromptSubmit` | Yes | Yes | User prompt submission | Inject additional context into prompts |\n| `Stop` | Yes | Yes | Agent execution stop | Save session state before exit |\n| `SubagentStart` | No | Yes | Subagent initialization | Track parallel task spawning |\n| `SubagentStop` | Yes | Yes | Subagent completion | Aggregate results from parallel tasks |\n| `PreCompact` | Yes | Yes | Conversation compaction request | Archive full transcript before summarizing |\n| `PermissionRequest` | No | Yes | Permission dialog would be displayed | Custom permission handling |\n| `SessionStart` | No | Yes | Session initialization | Initialize logging and telemetry |\n| `SessionEnd` | No | Yes | Session termination | Clean up temporary resources |\n| `Notification` | No | Yes | Agent status messages | Send agent status updates to Slack or PagerDuty |\n\n## Common use cases\n\nHooks are flexible enough to handle many different scenarios. Here are some of the most common patterns organized by category.\n\n<Tabs>\n  <Tab title=\"Security\">\n    - Block dangerous commands (like `rm -rf /`, destructive SQL)\n    - Validate file paths before write operations\n    - Enforce allowlists/blocklists for tool usage\n  </Tab>\n  <Tab title=\"Logging\">\n    - Create audit trails of all agent actions\n    - Track execution metrics and performance\n    - Debug agent behavior in development\n  </Tab>\n  <Tab title=\"Tool interception\">\n    - Redirect file operations to sandboxed directories\n    - Inject environment variables or credentials\n    - Transform tool inputs or outputs\n  </Tab>\n  <Tab title=\"Authorization\">\n    - Implement role-based access control\n    - Require human approval for sensitive operations\n    - Rate limit specific tool usage\n  </Tab>\n</Tabs>\n\n## Configure hooks\n\nTo configure a hook for your agent, pass the hook in the `options.hooks` parameter when calling `query()`:\n\n<CodeGroup>",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "</CodeGroup>\n\nThe `hooks` option is a dictionary (Python) or object (TypeScript) where:\n- **Keys** are [hook event names](#available-hooks) (e.g., `'PreToolUse'`, `'PostToolUse'`, `'Stop'`)\n- **Values** are arrays of [matchers](#matchers), each containing an optional filter pattern and your [callback functions](#callback-function-inputs)\n\nYour hook callback functions receive [input data](#input-data) about the event and return a [response](#callback-outputs) so the agent knows to allow, block, or modify the operation.\n\n### Matchers\n\nUse matchers to filter which tools trigger your callbacks:\n\n| Option | Type | Default | Description |\n|--------|------|---------|-------------|\n| `matcher` | `string` | `undefined` | Regex pattern to match tool names. Built-in tools include `Bash`, `Read`, `Write`, `Edit`, `Glob`, `Grep`, `WebFetch`, `Task`, and others. MCP tools use the pattern `mcp__<server>__<action>`. |\n| `hooks` | `HookCallback[]` | - | Required. Array of callback functions to execute when the pattern matches |\n| `timeout` | `number` | `60` | Timeout in seconds; increase for hooks that make external API calls |\n\nUse the `matcher` pattern to target specific tools whenever possible. A matcher with `'Bash'` only runs for Bash commands, while omitting the pattern runs your callbacks for every tool call. Note that matchers only filter by **tool name**, not by file paths or other arguments—to filter by file path, check `tool_input.file_path` inside your callback.\n\nMatchers only apply to tool-based hooks (`PreToolUse`, `PostToolUse`, `PostToolUseFailure`, `PermissionRequest`). For lifecycle hooks like `Stop`, `SessionStart`, and `Notification`, matchers are ignored and the hook fires for all events of that type.\n\n<Tip>\n**Discovering tool names:** Check the `tools` array in the initial system message when your session starts, or add a hook without a matcher to log all tool calls.\n\n**MCP tool naming:** MCP tools always start with `mcp__` followed by the server name and action: `mcp__<server>__<action>`. For example, if you configure a server named `playwright`, its tools will be named `mcp__playwright__browser_screenshot`, `mcp__playwright__browser_click`, etc. The server name comes from the key you use in the `mcpServers` configuration.\n</Tip>\n\nThis example uses a matcher to run a hook only for file-modifying tools when the `PreToolUse` event fires:\n\n<CodeGroup>",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "</CodeGroup>\n\n### Callback function inputs\n\nEvery hook callback receives three arguments:\n\n1. **Input data** (`dict` / `HookInput`): Event details. See [input data](#input-data) for fields\n2. **Tool use ID** (`str | None` / `string | null`): Correlate `PreToolUse` and `PostToolUse` events\n3. **Context** (`HookContext`): In TypeScript, contains a `signal` property (`AbortSignal`) for cancellation. Pass this to async operations like `fetch()` so they automatically cancel if the hook times out. In Python, this argument is reserved for future use.\n\n### Input data\n\nThe first argument to your hook callback contains information about the event. Field names are identical across SDKs (both use snake_case).\n\n**Common fields** present in all hook types:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `hook_event_name` | `string` | The hook type (`PreToolUse`, `PostToolUse`, etc.) |\n| `session_id` | `string` | Current session identifier |\n| `transcript_path` | `string` | Path to the conversation transcript |\n| `cwd` | `string` | Current working directory |\n\n**Hook-specific fields** vary by hook type. Items marked <sup>TS</sup> are only available in the TypeScript SDK:\n\n| Field | Type | Description | Hooks |\n|-------|------|-------------|-------|\n| `tool_name` | `string` | Name of the tool being called | PreToolUse, PostToolUse, PostToolUseFailure<sup>TS</sup>, PermissionRequest<sup>TS</sup> |\n| `tool_input` | `object` | Arguments passed to the tool | PreToolUse, PostToolUse, PostToolUseFailure<sup>TS</sup>, PermissionRequest<sup>TS</sup> |\n| `tool_response` | `any` | Result returned from tool execution | PostToolUse |\n| `error` | `string` | Error message from tool execution failure | PostToolUseFailure<sup>TS</sup> |\n| `is_interrupt` | `boolean` | Whether the failure was caused by an interrupt | PostToolUseFailure<sup>TS</sup> |\n| `prompt` | `string` | The user's prompt text | UserPromptSubmit |\n| `stop_hook_active` | `boolean` | Whether a stop hook is currently processing | Stop, SubagentStop |\n| `agent_id` | `string` | Unique identifier for the subagent | SubagentStart<sup>TS</sup>, SubagentStop<sup>TS</sup> |\n| `agent_type` | `string` | Type/role of the subagent | SubagentStart<sup>TS</sup> |\n| `agent_transcript_path` | `string` | Path to the subagent's conversation transcript | SubagentStop<sup>TS</sup> |\n| `trigger` | `string` | What triggered compaction: `manual` or `auto` | PreCompact |\n| `custom_instructions` | `string` | Custom instructions provided for compaction | PreCompact |\n| `permission_suggestions` | `array` | Suggested permission updates for the tool | PermissionRequest<sup>TS</sup> |\n| `source` | `string` | How the session started: `startup`, `resume`, `clear`, or `compact` | SessionStart<sup>TS</sup> |\n| `reason` | `string` | Why the session ended: `clear`, `logout`, `prompt_input_exit`, `bypass_permissions_disabled`, or `other` | SessionEnd<sup>TS</sup> |\n| `message` | `string` | Status message from the agent | Notification<sup>TS</sup> |\n| `notification_type` | `string` | Type of notification: `permission_prompt`, `idle_prompt`, `auth_success`, or `elicitation_dialog` | Notification<sup>TS</sup> |\n| `title` | `string` | Optional title set by the agent | Notification<sup>TS</sup> |\n\nThe code below defines a hook callback that uses `tool_name` and `tool_input` to log details about each tool call:\n\n<CodeGroup>",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "</CodeGroup>\n\n### Callback outputs\n\nYour callback function returns an object that tells the SDK how to proceed. Return an empty object `{}` to allow the operation without changes. To block, modify, or add context to the operation, return an object with a `hookSpecificOutput` field containing your decision.\n\n**Top-level fields** (outside `hookSpecificOutput`):\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `continue` | `boolean` | Whether the agent should continue after this hook (default: `true`) |\n| `stopReason` | `string` | Message shown when `continue` is `false` |\n| `suppressOutput` | `boolean` | Hide stdout from the transcript (default: `false`) |\n| `systemMessage` | `string` | Message injected into the conversation for Claude to see |\n\n**Fields inside `hookSpecificOutput`**:\n\n| Field | Type | Hooks | Description |\n|-------|------|-------|-------------|\n| `hookEventName` | `string` | All | Required. Use `input.hook_event_name` to match the current event |\n| `permissionDecision` | `'allow'` \\| `'deny'` \\| `'ask'` | PreToolUse | Controls whether the tool executes |\n| `permissionDecisionReason` | `string` | PreToolUse | Explanation shown to Claude for the decision |\n| `updatedInput` | `object` | PreToolUse | Modified tool input (requires `permissionDecision: 'allow'`) |\n| `additionalContext` | `string` | PostToolUse, UserPromptSubmit, SessionStart<sup>TS</sup>, SubagentStart<sup>TS</sup> | Context added to the conversation |\n\nThis example blocks write operations to the `/etc` directory while injecting a system message to remind Claude about safe file practices:\n\n<CodeGroup>",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "</CodeGroup>\n\n#### Permission decision flow\n\nWhen multiple hooks or permission rules apply, the SDK evaluates them in this order:\n\n1. **Deny** rules are checked first (any match = immediate denial).\n2. **Ask** rules are checked second.\n3. **Allow** rules are checked third.\n4. **Default to Ask** if nothing matches.\n\nIf any hook returns `deny`, the operation is blocked—other hooks returning `allow` won't override it.\n\n#### Block a tool\n\nReturn a deny decision to prevent tool execution:\n\n<CodeGroup>",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "</CodeGroup>\n\n#### Modify tool input\n\nReturn updated input to change what the tool receives:\n\n<CodeGroup>",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "</CodeGroup>\n\n<Note>\nWhen using `updatedInput`, you must also include `permissionDecision`. Always return a new object rather than mutating the original `tool_input`.\n</Note>\n\n#### Add a system message\n\nInject context into the conversation:\n\n<CodeGroup>",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "</CodeGroup>\n\n#### Auto-approve specific tools\n\nBypass permission prompts for trusted tools. This is useful when you want certain operations to run without user confirmation:\n\n<CodeGroup>",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "</CodeGroup>\n\n<Note>\nThe `permissionDecision` field accepts three values: `'allow'` (auto-approve), `'deny'` (block), or `'ask'` (prompt for confirmation).\n</Note>\n\n## Handle advanced scenarios\n\nThese patterns help you build more sophisticated hook systems for complex use cases.\n\n### Chaining multiple hooks\n\nHooks execute in the order they appear in the array. Keep each hook focused on a single responsibility and chain multiple hooks for complex logic. This example runs all four hooks for every tool call (no matcher specified):\n\n<CodeGroup>",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "</CodeGroup>\n\n### Tool-specific matchers with regex\n\nUse regex patterns to match multiple tools:\n\n<CodeGroup>",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "</CodeGroup>\n\n<Note>\nMatchers only match **tool names**, not file paths or other arguments. To filter by file path, check `tool_input.file_path` inside your hook callback.\n</Note>\n\n### Tracking subagent activity\n\nUse `SubagentStop` hooks to monitor subagent completion. The `tool_use_id` helps correlate parent agent calls with their subagents:\n\n<CodeGroup>",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "</CodeGroup>\n\n### Async operations in hooks\n\nHooks can perform async operations like HTTP requests. Handle errors gracefully by catching exceptions instead of throwing them. In TypeScript, pass the `signal` to `fetch()` so the request cancels if the hook times out:\n\n<CodeGroup>",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "</CodeGroup>\n\n### Sending notifications (TypeScript only)\n\nUse `Notification` hooks to receive status updates from the agent and forward them to external services like Slack or monitoring dashboards:",
      "language": "unknown"
    },
    {
      "code": "## Fix common issues\n\nThis section covers common issues and how to resolve them.\n\n### Hook not firing\n\n- Verify the hook event name is correct and case-sensitive (`PreToolUse`, not `preToolUse`)\n- Check that your matcher pattern matches the tool name exactly\n- Ensure the hook is under the correct event type in `options.hooks`\n- For `SubagentStop`, `Stop`, `SessionStart`, `SessionEnd`, and `Notification` hooks, matchers are ignored. These hooks fire for all events of that type.\n- Hooks may not fire when the agent hits the [`max_turns`](/docs/en/agent-sdk/python#configuration-options) limit because the session ends before hooks can execute\n\n### Matcher not filtering as expected\n\nMatchers only match **tool names**, not file paths or other arguments. To filter by file path, check `tool_input.file_path` inside your hook:",
      "language": "unknown"
    },
    {
      "code": "### Hook timeout\n\n- Increase the `timeout` value in the `HookMatcher` configuration\n- Use the `AbortSignal` from the third callback argument to handle cancellation gracefully in TypeScript\n\n### Tool blocked unexpectedly\n\n- Check all `PreToolUse` hooks for `permissionDecision: 'deny'` returns\n- Add logging to your hooks to see what `permissionDecisionReason` they're returning\n- Verify matcher patterns aren't too broad (an empty matcher matches all tools)\n\n### Modified input not applied\n\n- Ensure `updatedInput` is inside `hookSpecificOutput`, not at the top level:",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "Available hooks",
      "id": "available-hooks"
    },
    {
      "level": "h2",
      "text": "Common use cases",
      "id": "common-use-cases"
    },
    {
      "level": "h2",
      "text": "Configure hooks",
      "id": "configure-hooks"
    },
    {
      "level": "h3",
      "text": "Matchers",
      "id": "matchers"
    },
    {
      "level": "h3",
      "text": "Callback function inputs",
      "id": "callback-function-inputs"
    },
    {
      "level": "h3",
      "text": "Input data",
      "id": "input-data"
    },
    {
      "level": "h3",
      "text": "Callback outputs",
      "id": "callback-outputs"
    },
    {
      "level": "h2",
      "text": "Handle advanced scenarios",
      "id": "handle-advanced-scenarios"
    },
    {
      "level": "h3",
      "text": "Chaining multiple hooks",
      "id": "chaining-multiple-hooks"
    },
    {
      "level": "h3",
      "text": "Tool-specific matchers with regex",
      "id": "tool-specific-matchers-with-regex"
    },
    {
      "level": "h3",
      "text": "Tracking subagent activity",
      "id": "tracking-subagent-activity"
    },
    {
      "level": "h3",
      "text": "Async operations in hooks",
      "id": "async-operations-in-hooks"
    },
    {
      "level": "h3",
      "text": "Sending notifications (TypeScript only)",
      "id": "sending-notifications-(typescript-only)"
    },
    {
      "level": "h2",
      "text": "Fix common issues",
      "id": "fix-common-issues"
    },
    {
      "level": "h3",
      "text": "Hook not firing",
      "id": "hook-not-firing"
    },
    {
      "level": "h3",
      "text": "Matcher not filtering as expected",
      "id": "matcher-not-filtering-as-expected"
    },
    {
      "level": "h3",
      "text": "Hook timeout",
      "id": "hook-timeout"
    },
    {
      "level": "h3",
      "text": "Tool blocked unexpectedly",
      "id": "tool-blocked-unexpectedly"
    },
    {
      "level": "h3",
      "text": "Modified input not applied",
      "id": "modified-input-not-applied"
    },
    {
      "level": "h3",
      "text": "Session hooks not available",
      "id": "session-hooks-not-available"
    },
    {
      "level": "h3",
      "text": "Subagent permission prompts multiplying",
      "id": "subagent-permission-prompts-multiplying"
    },
    {
      "level": "h3",
      "text": "Recursive hook loops with subagents",
      "id": "recursive-hook-loops-with-subagents"
    },
    {
      "level": "h3",
      "text": "systemMessage not appearing in output",
      "id": "systemmessage-not-appearing-in-output"
    },
    {
      "level": "h2",
      "text": "Learn more",
      "id": "learn-more"
    }
  ],
  "url": "llms-txt#define-a-hook-callback-that-receives-tool-call-details",
  "links": []
}