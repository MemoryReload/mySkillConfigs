{
  "title": "Handle approvals and user input",
  "content": "Surface Claude's approval requests and clarifying questions to users, then return their decisions to the SDK.\n\nWhile working on a task, Claude sometimes needs to check in with users. It might need permission before deleting files, or need to ask which database to use for a new project. Your application needs to surface these requests to users so Claude can continue with their input.\n\nClaude requests user input in two situations: when it needs **permission to use a tool** (like deleting files or running commands), and when it has **clarifying questions** (via the `AskUserQuestion` tool). Both trigger your `canUseTool` callback, which pauses execution until you return a response. This is different from normal conversation turns where Claude finishes and waits for your next message.\n\nFor clarifying questions, Claude generates the questions and options. Your role is to present them to users and return their selections. You can't add your own questions to this flow; if you need to ask users something yourself, do that separately in your application logic.\n\nThis guide shows you how to detect each type of request and respond appropriately.\n\n## Detect when Claude needs input\n\nPass a `canUseTool` callback in your query options. The callback fires whenever Claude needs user input, receiving the tool name and input as arguments:\n\nThe callback fires in two cases:\n\n1. **Tool needs approval**: Claude wants to use a tool that isn't auto-approved by [permission rules](/docs/en/agent-sdk/permissions) or modes. Check `tool_name` for the tool (e.g., `\"Bash\"`, `\"Write\"`).\n2. **Claude asks a question**: Claude calls the `AskUserQuestion` tool. Check if `tool_name == \"AskUserQuestion\"` to handle it differently. If you specify a `tools` array, include `AskUserQuestion` for this to work. See [Handle clarifying questions](#handle-clarifying-questions) for details.\n\nYour callback must return within **60 seconds** or Claude will assume the request was denied and try a different approach.\n\n<Note>\nTo automatically allow or deny tools without prompting users, use [hooks](/docs/en/agent-sdk/hooks) instead. Hooks execute before `canUseTool` and can allow, deny, or modify requests based on your own logic. You can also use the [`PermissionRequest` hook](/docs/en/agent-sdk/hooks#available-hooks) to send external notifications (Slack, email, push) when Claude is waiting for approval.\n</Note>\n\n## Handle tool approval requests\n\nOnce you've passed a `canUseTool` callback in your query options, it fires when Claude wants to use a tool that isn't auto-approved. Your callback receives two arguments:\n\n| Argument | Description |\n|----------|-------------|\n| `toolName` | The name of the tool Claude wants to use (e.g., `\"Bash\"`, `\"Write\"`, `\"Edit\"`) |\n| `input` | The parameters Claude is passing to the tool. Contents vary by tool. |\n\nThe `input` object contains tool-specific parameters. Common examples:\n\n| Tool | Input fields |\n|------|--------------|\n| `Bash` | `command`, `description`, `timeout` |\n| `Write` | `file_path`, `content` |\n| `Edit` | `file_path`, `old_string`, `new_string` |\n| `Read` | `file_path`, `offset`, `limit` |\n\nSee the SDK reference for complete input schemas: [Python](/docs/en/agent-sdk/python#tool-inputoutput-types) | [TypeScript](/docs/en/agent-sdk/typescript#tool-input-types).\n\nYou can display this information to the user so they can decide whether to allow or reject the action, then return the appropriate response.\n\nThe following example asks Claude to create and delete a test file. When Claude attempts each operation, the callback prints the tool request to the terminal and prompts for y/n approval.\n\n```python Python\nimport asyncio\n\nfrom claude_agent_sdk import ClaudeAgentOptions, query\nfrom claude_agent_sdk.types import (\n    HookMatcher,\n    PermissionResultAllow,\n    PermissionResultDeny,\n    ToolPermissionContext,\n)\n\nasync def can_use_tool(\n    tool_name: str, input_data: dict, context: ToolPermissionContext\n) -> PermissionResultAllow | PermissionResultDeny:\n    # Display the tool request\n    print(f\"\\nTool: {tool_name}\")\n    if tool_name == \"Bash\":\n        print(f\"Command: {input_data.get('command')}\")\n        if input_data.get(\"description\"):\n            print(f\"Description: {input_data.get('description')}\")\n    else:\n        print(f\"Input: {input_data}\")\n\n# Get user approval\n    response = input(\"Allow this action? (y/n): \")\n\n# Return allow or deny based on user's response\n    if response.lower() == \"y\":\n        # Allow: tool executes with the original (or modified) input\n        return PermissionResultAllow(updated_input=input_data)\n    else:\n        # Deny: tool doesn't execute, Claude sees the message\n        return PermissionResultDeny(message=\"User denied this action\")",
  "code_samples": [
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "</CodeGroup>\n\nThe callback fires in two cases:\n\n1. **Tool needs approval**: Claude wants to use a tool that isn't auto-approved by [permission rules](/docs/en/agent-sdk/permissions) or modes. Check `tool_name` for the tool (e.g., `\"Bash\"`, `\"Write\"`).\n2. **Claude asks a question**: Claude calls the `AskUserQuestion` tool. Check if `tool_name == \"AskUserQuestion\"` to handle it differently. If you specify a `tools` array, include `AskUserQuestion` for this to work. See [Handle clarifying questions](#handle-clarifying-questions) for details.\n\nYour callback must return within **60 seconds** or Claude will assume the request was denied and try a different approach.\n\n<Note>\nTo automatically allow or deny tools without prompting users, use [hooks](/docs/en/agent-sdk/hooks) instead. Hooks execute before `canUseTool` and can allow, deny, or modify requests based on your own logic. You can also use the [`PermissionRequest` hook](/docs/en/agent-sdk/hooks#available-hooks) to send external notifications (Slack, email, push) when Claude is waiting for approval.\n</Note>\n\n## Handle tool approval requests\n\nOnce you've passed a `canUseTool` callback in your query options, it fires when Claude wants to use a tool that isn't auto-approved. Your callback receives two arguments:\n\n| Argument | Description |\n|----------|-------------|\n| `toolName` | The name of the tool Claude wants to use (e.g., `\"Bash\"`, `\"Write\"`, `\"Edit\"`) |\n| `input` | The parameters Claude is passing to the tool. Contents vary by tool. |\n\nThe `input` object contains tool-specific parameters. Common examples:\n\n| Tool | Input fields |\n|------|--------------|\n| `Bash` | `command`, `description`, `timeout` |\n| `Write` | `file_path`, `content` |\n| `Edit` | `file_path`, `old_string`, `new_string` |\n| `Read` | `file_path`, `offset`, `limit` |\n\nSee the SDK reference for complete input schemas: [Python](/docs/en/agent-sdk/python#tool-inputoutput-types) | [TypeScript](/docs/en/agent-sdk/typescript#tool-input-types).\n\nYou can display this information to the user so they can decide whether to allow or reject the action, then return the appropriate response.\n\nThe following example asks Claude to create and delete a test file. When Claude attempts each operation, the callback prints the tool request to the terminal and prompts for y/n approval.\n\n<CodeGroup>",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "Detect when Claude needs input",
      "id": "detect-when-claude-needs-input"
    },
    {
      "level": "h2",
      "text": "Handle tool approval requests",
      "id": "handle-tool-approval-requests"
    }
  ],
  "url": "llms-txt#handle-approvals-and-user-input",
  "links": []
}