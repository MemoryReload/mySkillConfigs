{
  "title": "Example: Tracking usage in a conversation",
  "content": "async def track_usage():\n    # Process messages as they arrive\n    async for message in query(\n        prompt=\"Analyze this codebase and run tests\"\n    ):\n        if isinstance(message, AssistantMessage) and hasattr(message, 'usage'):\n            print(f\"Message ID: {message.id}\")\n            print(f\"Usage: {message.usage}\")\n\nasyncio.run(track_usage())\n\n<!-- Step 1: Initial request with parallel tool uses -->\nassistant (text)      { id: \"msg_1\", usage: { output_tokens: 100, ... } }\nassistant (tool_use)  { id: \"msg_1\", usage: { output_tokens: 100, ... } }\nassistant (tool_use)  { id: \"msg_1\", usage: { output_tokens: 100, ... } }\nassistant (tool_use)  { id: \"msg_1\", usage: { output_tokens: 100, ... } }\nuser (tool_result)\nuser (tool_result)\nuser (tool_result)\n\n<!-- Step 2: Follow-up response -->\nassistant (text)      { id: \"msg_2\", usage: { output_tokens: 98, ... } }\ntypescript\n// All these messages have the same ID and usage\nconst messages = [\n  { type: 'assistant', id: 'msg_123', usage: { output_tokens: 100 } },\n  { type: 'assistant', id: 'msg_123', usage: { output_tokens: 100 } },\n  { type: 'assistant', id: 'msg_123', usage: { output_tokens: 100 } }\n];\n\n// Charge only once per unique message ID\nconst uniqueUsage = messages[0].usage; // Same for all messages with this ID\ntypescript\n// Final result includes total usage\nconst result = await query({\n  prompt: \"Multi-step task\",\n  options: { /* ... */ }\n});\n\nconsole.log(\"Total usage:\", result.usage);\nconsole.log(\"Total cost:\", result.usage.total_cost_usd);\ntypescript\n// modelUsage provides per-model breakdown\ntype ModelUsage = {\n  inputTokens: number\n  outputTokens: number\n  cacheReadInputTokens: number\n  cacheCreationInputTokens: number\n  webSearchRequests: number\n  costUSD: number\n  contextWindow: number\n}\n\n// Access from result message\nconst result = await query({ prompt: \"...\" });\n\n// result.modelUsage is a map of model name to ModelUsage\nfor (const [modelName, usage] of Object.entries(result.modelUsage)) {\n  console.log(`${modelName}: $${usage.costUSD.toFixed(4)}`);\n  console.log(`  Input tokens: ${usage.inputTokens}`);\n  console.log(`  Output tokens: ${usage.outputTokens}`);\n}\ntypescript TypeScript\nimport { query } from \"@anthropic-ai/claude-agent-sdk\";\n\nclass CostTracker {\n  private processedMessageIds = new Set<string>();\n  private stepUsages: Array<any> = [];\n  \n  async trackConversation(prompt: string) {\n    const result = await query({\n      prompt,\n      options: {\n        onMessage: (message) => {\n          this.processMessage(message);\n        }\n      }\n    });\n    \n    return {\n      result,\n      stepUsages: this.stepUsages,\n      totalCost: result.usage?.total_cost_usd || 0\n    };\n  }\n  \n  private processMessage(message: any) {\n    // Only process assistant messages with usage\n    if (message.type !== 'assistant' || !message.usage) {\n      return;\n    }\n    \n    // Skip if we've already processed this message ID\n    if (this.processedMessageIds.has(message.id)) {\n      return;\n    }\n    \n    // Mark as processed and record usage\n    this.processedMessageIds.add(message.id);\n    this.stepUsages.push({\n      messageId: message.id,\n      timestamp: new Date().toISOString(),\n      usage: message.usage,\n      costUSD: this.calculateCost(message.usage)\n    });\n  }\n  \n  private calculateCost(usage: any): number {\n    // Implement your pricing calculation here\n    // This is a simplified example\n    const inputCost = usage.input_tokens * 0.00003;\n    const outputCost = usage.output_tokens * 0.00015;\n    const cacheReadCost = (usage.cache_read_input_tokens || 0) * 0.0000075;\n    \n    return inputCost + outputCost + cacheReadCost;\n  }\n}\n\n// Usage\nconst tracker = new CostTracker();\nconst { result, stepUsages, totalCost } = await tracker.trackConversation(\n  \"Analyze and refactor this code\"\n);\n\nconsole.log(`Steps processed: ${stepUsages.length}`);\nconsole.log(`Total cost: $${totalCost.toFixed(4)}`);\npython Python\nfrom claude_agent_sdk import query, AssistantMessage, ResultMessage\nfrom datetime import datetime\nimport asyncio\n\nclass CostTracker:\n    def __init__(self):\n        self.processed_message_ids = set()\n        self.step_usages = []\n\nasync def track_conversation(self, prompt):\n        result = None\n\n# Process messages as they arrive\n        async for message in query(prompt=prompt):\n            self.process_message(message)\n\n# Capture the final result message\n            if isinstance(message, ResultMessage):\n                result = message\n\nreturn {\n            \"result\": result,\n            \"step_usages\": self.step_usages,\n            \"total_cost\": result.total_cost_usd if result else 0\n        }\n\ndef process_message(self, message):\n        # Only process assistant messages with usage\n        if not isinstance(message, AssistantMessage) or not hasattr(message, 'usage'):\n            return\n\n# Skip if already processed this message ID\n        message_id = getattr(message, 'id', None)\n        if not message_id or message_id in self.processed_message_ids:\n            return\n\n# Mark as processed and record usage\n        self.processed_message_ids.add(message_id)\n        self.step_usages.append({\n            \"message_id\": message_id,\n            \"timestamp\": datetime.now().isoformat(),\n            \"usage\": message.usage,\n            \"cost_usd\": self.calculate_cost(message.usage)\n        })\n\ndef calculate_cost(self, usage):\n        # Implement your pricing calculation\n        input_cost = usage.get(\"input_tokens\", 0) * 0.00003\n        output_cost = usage.get(\"output_tokens\", 0) * 0.00015\n        cache_read_cost = usage.get(\"cache_read_input_tokens\", 0) * 0.0000075\n\nreturn input_cost + output_cost + cache_read_cost",
  "code_samples": [
    {
      "code": "</CodeGroup>\n\n### Message Flow Example\n\nHere's how messages and usage are reported in a typical multi-step conversation:",
      "language": "unknown"
    },
    {
      "code": "## Important Usage Rules\n\n### 1. Same ID = Same Usage\n\n**All messages with the same `id` field report identical usage**. When Claude sends multiple messages in the same turn (e.g., text + tool uses), they share the same message ID and usage data.",
      "language": "unknown"
    },
    {
      "code": "### 2. Charge Once Per Step\n\n**You should only charge users once per step**, not for each individual message. When you see multiple assistant messages with the same ID, use the usage from any one of them.\n\n### 3. Result Message Contains Cumulative Usage\n\nThe final `result` message contains the total cumulative usage from all steps in the conversation:",
      "language": "unknown"
    },
    {
      "code": "### 4. Per-Model Usage Breakdown\n\nThe result message also includes `modelUsage`, which provides authoritative per-model usage data. Like `total_cost_usd`, this field is accurate and suitable for billing purposes. This is especially useful when using multiple models (e.g., Haiku for subagents, Opus for the main agent).",
      "language": "unknown"
    },
    {
      "code": "For the complete type definitions, see the [TypeScript SDK reference](/docs/en/agent-sdk/typescript).\n\n## Implementation: Cost Tracking System\n\nHere's a complete example of implementing a cost tracking system:\n\n<CodeGroup>",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h3",
      "text": "Message Flow Example",
      "id": "message-flow-example"
    },
    {
      "level": "h2",
      "text": "Important Usage Rules",
      "id": "important-usage-rules"
    },
    {
      "level": "h3",
      "text": "1. Same ID = Same Usage",
      "id": "1.-same-id-=-same-usage"
    },
    {
      "level": "h3",
      "text": "2. Charge Once Per Step",
      "id": "2.-charge-once-per-step"
    },
    {
      "level": "h3",
      "text": "3. Result Message Contains Cumulative Usage",
      "id": "3.-result-message-contains-cumulative-usage"
    },
    {
      "level": "h3",
      "text": "4. Per-Model Usage Breakdown",
      "id": "4.-per-model-usage-breakdown"
    },
    {
      "level": "h2",
      "text": "Implementation: Cost Tracking System",
      "id": "implementation:-cost-tracking-system"
    }
  ],
  "url": "llms-txt#example:-tracking-usage-in-a-conversation",
  "links": []
}