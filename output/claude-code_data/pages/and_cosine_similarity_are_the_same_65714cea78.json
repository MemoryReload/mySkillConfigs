{
  "title": "and cosine similarity are the same.",
  "content": "similarities = np.dot(doc_embds, query_embd)\n\nretrieved_id = np.argmax(similarities)\nprint(documents[retrieved_id])\n\nApple's conference call to discuss fourth fiscal quarter results and business updates is scheduled for Thursday, November 2, 2023 at 2:00 p.m. PT / 5:00 p.m. ET.\npython\n    import voyageai\n    import numpy as np\n\ndef embd_normalize(v: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Normalize the rows of a 2D numpy array to unit vectors by dividing each row by its Euclidean\n        norm. Raises a ValueError if any row has a norm of zero to prevent division by zero.\n        \"\"\"\n        row_norms = np.linalg.norm(v, axis=1, keepdims=True)\n        if np.any(row_norms == 0):\n            raise ValueError(\"Cannot normalize rows with a norm of zero.\")\n        return v / row_norms\n\nvo = voyageai.Client()\n\n# Generate voyage-code-3 vectors, which by default are 1024-dimensional floating-point numbers\n    embd = vo.embed(['Sample text 1', 'Sample text 2'], model='voyage-code-3').embeddings\n\n# Set shorter dimension\n    short_dim = 256\n\n# Resize and normalize vectors to shorter dimension\n    resized_embd = embd_normalize(np.array(embd)[:, :short_dim]).tolist()\n    ```\n  \n</section>\n\nVisit Voyage's [pricing page](https://docs.voyageai.com/docs/pricing?ref=anthropic) for the most up to date pricing details.",
  "code_samples": [
    {
      "code": "Note that we use `input_type=\"document\"` and `input_type=\"query\"` for embedding the document and query, respectively. More specification can be found [here](/docs/en/build-with-claude/embeddings#voyage-python-package).\n\nThe output would be the 5th document, which is indeed the most relevant to the query:",
      "language": "unknown"
    },
    {
      "code": "If you are looking for a detailed set of cookbooks on how to do RAG with embeddings, including vector databases, check out our [RAG cookbook](https://platform.claude.com/cookbook/third-party-pinecone-rag-using-pinecone).\n\n## FAQ\n\n  <section title=\"Why do Voyage embeddings have superior quality?\">\n\n    Embedding models rely on powerful neural networks to capture and compress semantic context, similar to generative models. Voyage's team of experienced AI researchers optimizes every component of the embedding process, including:\n    - Model architecture \n    - Data collection\n    - Loss functions\n    - Optimizer selection\n\n    Learn more about Voyage's technical approach on their [blog](https://blog.voyageai.com/).\n  \n</section>\n\n  <section title=\"What embedding models are available and which should I use?\">\n\n    For general-purpose embedding, we recommend:\n    - `voyage-3-large`: Best quality\n    - `voyage-3.5-lite`: Lowest latency and cost\n    - `voyage-3.5`: Balanced performance with superior retrieval quality at a competitive price point \n    \n    For retrieval, use the `input_type` parameter to specify whether the text is a query or document type.\n\n    Domain-specific models:\n\n    - Legal tasks: `voyage-law-2`\n    - Code and programming documentation: `voyage-code-3`\n    - Finance-related tasks: `voyage-finance-2`\n  \n</section>\n\n  <section title=\"Which similarity function should I use?\">\n\n    You can use Voyage embeddings with either dot-product similarity, cosine similarity, or Euclidean distance. An explanation about embedding similarity can be found [here](https://www.pinecone.io/learn/vector-similarity/).\n\n    Voyage AI embeddings are normalized to length 1, which means that:\n\n    - Cosine similarity is equivalent to dot-product similarity, while the latter can be computed more quickly.\n    - Cosine similarity and Euclidean distance will result in the identical rankings.\n  \n</section>\n\n  <section title=\"What is the relationship between characters, words, and tokens?\">\n\n    Please see this [page](https://docs.voyageai.com/docs/tokenization?ref=anthropic).\n  \n</section>\n\n  <section title=\"When and how should I use the input_type parameter?\">\n\n    For all retrieval tasks and use cases (e.g., RAG), we recommend that the `input_type` parameter be used to specify whether the input text is a query or document. Do not omit `input_type` or set `input_type=None`. Specifying whether input text is a query or document can create better dense vector representations for retrieval, which can lead to better retrieval quality.\n\n    When using the `input_type` parameter, special prompts are prepended to the input text prior to embedding. Specifically:\n\n    > ðŸ“˜ **Prompts associated with `input_type`**\n    > \n    > - For a query, the prompt is â€œRepresent the query for retrieving supporting documents: â€œ.\n    > - For a document, the prompt is â€œRepresent the document for retrieval: â€œ.\n    > - Example\n    >     - When `input_type=\"query\"`, a query like \"When is Apple's conference call scheduled?\" will become \"**Represent the query for retrieving supporting documents:** When is Apple's conference call scheduled?\"\n    >     - When `input_type=\"document\"`, a query like \"Apple's conference call to discuss fourth fiscal quarter results and business updates is scheduled for Thursday, November 2, 2023 at 2:00 p.m. PT / 5:00 p.m. ET.\" will become \"**Represent the document for retrieval:** Apple's conference call to discuss fourth fiscal quarter results and business updates is scheduled for Thursday, November 2, 2023 at 2:00 p.m. PT / 5:00 p.m. ET.\"\n\n    `voyage-large-2-instruct`, as the name suggests, is trained to be responsive to additional instructions that are prepended to the input text. For classification, clustering, or other [MTEB](https://huggingface.co/mteb) subtasks, please use the instructions [here](https://github.com/voyage-ai/voyage-large-2-instruct).\n  \n</section>\n\n  <section title=\"What quantization options are available?\">\n\n    Quantization in embeddings converts high-precision values, like 32-bit single-precision floating-point numbers, to lower-precision formats such as 8-bit integers or 1-bit binary values, reducing storage, memory, and costs by 4x and 32x, respectively. Supported Voyage models enable quantization by specifying the output data type with the `output_dtype` parameter:\n\n    - `float`: Each returned embedding is a list of 32-bit (4-byte) single-precision floating-point numbers. This is the default and provides the highest precision / retrieval accuracy.\n    - `int8` and `uint8`: Each returned embedding is a list of 8-bit (1-byte) integers ranging from -128 to 127 and 0 to 255, respectively.\n    - `binary` and `ubinary`: Each returned embedding is a list of 8-bit integers that represent bit-packed, quantized single-bit embedding values: `int8` for `binary` and `uint8` for `ubinary`. The length of the returned list of integers is 1/8 of the actual dimension of the embedding. The binary type uses the offset binary method, which you can learn more about in the FAQ below.\n\n    > **Binary quantization example**\n    > \n    > Consider the following eight embedding values: -0.03955078, 0.006214142, -0.07446289, -0.039001465, 0.0046463013, 0.00030612946, -0.08496094, and 0.03994751. With binary quantization, values less than or equal to zero will be quantized to a binary zero, and positive values to a binary one, resulting in the following binary sequence: 0, 1, 0, 0, 1, 1, 0, 1. These eight bits are then packed into a single 8-bit integer, 01001101 (with the leftmost bit as the most significant bit).\n    >   - `ubinary`: The binary sequence is directly converted and represented as the unsigned integer (`uint8`) 77.\n    >   - `binary`: The binary sequence is represented as the signed integer (`int8`) -51, calculated using the offset binary method (77 - 128 = -51).\n  \n</section>\n\n  <section title=\"How can I truncate Matryoshka embeddings?\">\n\n    Matryoshka learning creates embeddings with coarse-to-fine representations within a single vector. Voyage models, such as `voyage-code-3`, that support multiple output dimensions generate such Matryoshka embeddings. You can truncate these vectors by keeping the leading subset of dimensions. For example, the following Python code demonstrates how to truncate 1024-dimensional vectors to 256 dimensions:",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "FAQ",
      "id": "faq"
    },
    {
      "level": "h2",
      "text": "Pricing",
      "id": "pricing"
    }
  ],
  "url": "llms-txt#and-cosine-similarity-are-the-same.",
  "links": []
}