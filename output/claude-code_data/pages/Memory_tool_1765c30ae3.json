{
  "title": "Memory tool",
  "content": "The memory tool enables Claude to store and retrieve information across conversations through a memory file directory. Claude can create, read, update, and delete files that persist between sessions, allowing it to build knowledge over time without keeping everything in the context window.\n\nThe memory tool operates client-side—you control where and how the data is stored through your own infrastructure.\n\n<Note>\nThe memory tool is currently in beta. To enable it, use the beta header `context-management-2025-06-27` in your API requests.\n\nPlease reach out through our [feedback form](https://forms.gle/YXC2EKGMhjN1c4L88) to share your feedback on this feature.\n</Note>\n\n- Maintain project context across multiple agent executions\n- Learn from past interactions, decisions, and feedback\n- Build knowledge bases over time\n- Enable cross-conversation learning where Claude improves at recurring workflows\n\nWhen enabled, Claude automatically checks its memory directory before starting tasks. Claude can create, read, update, and delete files in the `/memories` directory to store what it learns while working, then reference those memories in future conversations to handle similar tasks more effectively or pick up where it left off.\n\nSince this is a client-side tool, Claude makes tool calls to perform memory operations, and your application executes those operations locally. This gives you complete control over where and how the memory is stored. For security, you should restrict all memory operations to the `/memories` directory.\n\n### Example: How memory tool calls work\n\nWhen you ask Claude to help with a task, Claude automatically checks its memory directory first. Here's what a typical interaction looks like:\n\n**2. Claude checks the memory directory:**\n\nClaude calls the memory tool:\n\n**3. Your application returns the directory contents:**\n\n**4. Claude reads relevant files:**\n\n**5. Your application returns the file contents:**\n\n**6. Claude uses the memory to help:**\n\nThe memory tool is available on:\n\n- Claude Sonnet 4.5 (`claude-sonnet-4-5-20250929`)\n- Claude Sonnet 4 (`claude-sonnet-4-20250514`)\n- Claude Haiku 4.5 (`claude-haiku-4-5-20251001`)\n- Claude Opus 4.5 (`claude-opus-4-5-20251101`)\n- Claude Opus 4.1 (`claude-opus-4-1-20250805`)\n- Claude Opus 4 (`claude-opus-4-20250514`)\n\nTo use the memory tool:\n\n1. Include the beta header `context-management-2025-06-27` in your API requests\n2. Add the memory tool to your request\n3. Implement client-side handlers for memory operations\n\n<Note>\nTo handle memory tool operations in your application, you need to implement handlers for each memory command. Our SDKs provide memory tool helpers that handle the tool interface—you can subclass `BetaAbstractMemoryTool` (Python) or use `betaMemoryTool` (TypeScript) to implement your own memory backend (file-based, database, cloud storage, encrypted files, etc.).\n\nFor working examples, see:\n- Python: [examples/memory/basic.py](https://github.com/anthropics/anthropic-sdk-python/blob/main/examples/memory/basic.py)\n- TypeScript: [examples/tools-helpers-memory.ts](https://github.com/anthropics/anthropic-sdk-typescript/blob/main/examples/tools-helpers-memory.ts)\n</Note>\n\npython\\ndef fetch_page(url, retries=3):\\n    for i in range(retries):\\n        try:\\n            response = requests.get(url, timeout=5)\\n            return response.text\\n        except requests.exceptions.Timeout:\\n            if i == retries - 1:\\n                raise\\n            time.sleep(1)\\n\n\npython\\ndef fetch_page(url, retries=3):\\n    for i in range(retries):\\n        try:\\n            response = requests.get(url, timeout=5)\\n            return response.text\\n        except requests.exceptions.Timeout:\\n            if i == retries - 1:\\n                raise\\n            time.sleep(1)\\n\n\npython\\ndef fetch_page(url, retries=3):\\n    for i in range(retries):\\n        try:\\n            response = requests.get(url, timeout=5)\\n            return response.text\\n        except requests.exceptions.Timeout:\\n            if i == retries - 1:\\n                raise\\n            time.sleep(1)\\n\n\nYour client-side implementation needs to handle these memory tool commands. While these specifications describe the recommended behaviors that Claude is most familiar with, you can modify your implementation and return strings as needed for your use case.\n\n### view\nShows directory contents or file contents with optional line ranges:\n\n**For directories:** Return a listing that shows files and directories with their sizes:\n\n- Lists files up to 2 levels deep\n- Shows human-readable sizes (e.g., `5.5K`, `1.2M`)\n- Excludes hidden items (files starting with `.`) and `node_modules`\n- Uses tab character between size and path\n\n**For files:** Return file contents with a header and line numbers:\n\nLine number formatting:\n- **Width**: 6 characters, right-aligned with space padding\n- **Separator**: Tab character between line number and content\n- **Indexing**: 1-indexed (first line is line 1)\n- **Line limit**: Files with more than 999,999 lines should return an error: `\"File {path} exceeds maximum line limit of 999,999 lines.\"`\n\n- **File/directory does not exist**: `\"The path {path} does not exist. Please provide a valid path.\"`\n\n### create\nCreate a new file:\n\n- **Success**: `\"File created successfully at: {path}\"`\n\n- **File already exists**: `\"Error: File {path} already exists\"`\n\n### str_replace\nReplace text in a file:\n\n- **Success**: `\"The memory file has been edited.\"` followed by a snippet of the edited file with line numbers\n\n- **File does not exist**: `\"Error: The path {path} does not exist. Please provide a valid path.\"`\n- **Text not found**: ``\"No replacement was performed, old_str `{old_str}` did not appear verbatim in {path}.\"``\n- **Duplicate text**: When `old_str` appears multiple times, return: ``\"No replacement was performed. Multiple occurrences of old_str `{old_str}` in lines: {line_numbers}. Please ensure it is unique\"``\n\n#### Directory handling\n\nIf the path is a directory, return a \"file does not exist\" error.\n\n### insert\nInsert text at a specific line:\n\n- **Success**: `\"The file {path} has been edited.\"`\n\n- **File does not exist**: `\"Error: The path {path} does not exist\"`\n- **Invalid line number**: ``\"Error: Invalid `insert_line` parameter: {insert_line}. It should be within the range of lines of the file: [0, {n_lines}]\"``\n\n#### Directory handling\n\nIf the path is a directory, return a \"file does not exist\" error.\n\n### delete\nDelete a file or directory:\n\n- **Success**: `\"Successfully deleted {path}\"`\n\n- **File/directory does not exist**: `\"Error: The path {path} does not exist\"`\n\n#### Directory handling\n\nDeletes the directory and all its contents recursively.\n\n### rename\nRename or move a file/directory:\n\n- **Success**: `\"Successfully renamed {old_path} to {new_path}\"`\n\n- **Source does not exist**: `\"Error: The path {old_path} does not exist\"`\n- **Destination already exists**: Return an error (do not overwrite): `\"Error: The destination {new_path} already exists\"`\n\n#### Directory handling\n\nRenames the directory.\n\n## Prompting guidance\n\nWe automatically include this instruction to the system prompt when the memory tool is included:\n\nIf you observe Claude creating cluttered memory files, you can include this instruction:\n\n> Note: when editing your memory folder, always try to keep its content up-to-date, coherent and organized. You can rename or delete files that are no longer relevant. Do not create new files unless necessary.\n\nYou can also guide what Claude writes to memory, e.g., \"Only write down information relevant to \\<topic\\> in your memory system.\"\n\n## Security considerations\n\nHere are important security concerns when implementing your memory store:\n\n### Sensitive information\nClaude will usually refuse to write down sensitive information in memory files. However, you may want to implement stricter validation that strips out potentially sensitive information.\n\n### File storage size\nConsider tracking memory file sizes and preventing files from growing too large. Consider adding a maximum number of characters the memory read command can return, and let Claude paginate through contents.\n\n### Memory expiration\nConsider clearing out memory files periodically that haven't been accessed in an extended time.\n\n### Path traversal protection\n\n<Warning>\nMalicious path inputs could attempt to access files outside the `/memories` directory. Your implementation **MUST** validate all paths to prevent directory traversal attacks.\n</Warning>\n\nConsider these safeguards:\n\n- Validate that all paths start with `/memories`\n- Resolve paths to their canonical form and verify they remain within the memory directory\n- Reject paths containing sequences like `../`, `..\\\\`, or other traversal patterns\n- Watch for URL-encoded traversal sequences (`%2e%2e%2f`)\n- Use your language's built-in path security utilities (e.g., Python's `pathlib.Path.resolve()` and `relative_to()`)\n\nThe memory tool uses similar error handling patterns to the [text editor tool](/docs/en/agents-and-tools/tool-use/text-editor-tool#handle-errors). See the individual tool command sections above for detailed error messages and behaviors. Common errors include file not found, permission errors, invalid paths, and duplicate text matches.\n\n## Using with Context Editing\n\nThe memory tool can be combined with [context editing](/docs/en/build-with-claude/context-editing), which automatically clears old tool results when conversation context grows beyond a configured threshold. This combination enables long-running agentic workflows that would otherwise exceed context limits.\n\n### How they work together\n\nWhen context editing is enabled and your conversation approaches the clearing threshold, Claude automatically receives a warning notification. This prompts Claude to preserve any important information from tool results into memory files before those results are cleared from the context window.\n\nAfter tool results are cleared, Claude can retrieve the stored information from memory files whenever needed, effectively treating memory as an extension of its working context. This allows Claude to:\n\n- Continue complex, multi-step workflows without losing critical information\n- Reference past work and decisions even after tool results are removed\n- Maintain coherent context across conversations that would exceed typical context limits\n- Build up a knowledge base over time while keeping the active context window manageable\n\nConsider a code refactoring project with many file operations:\n\n1. Claude makes numerous edits to files, generating many tool results\n2. As the context grows and approaches your threshold, Claude receives a warning\n3. Claude summarizes the changes made so far to a memory file (e.g., `/memories/refactoring_progress.xml`)\n4. Context editing clears the older tool results automatically\n5. Claude continues working, referencing the memory file when it needs to recall what changes were already completed\n6. The workflow can continue indefinitely, with Claude managing both active context and persistent memory\n\nTo use both features together:\n\nYou can also exclude memory tool calls from being cleared to ensure Claude always has access to recent memory operations:",
  "code_samples": [
    {
      "code": "\"Help me respond to this customer service ticket.\"",
      "language": "unknown"
    },
    {
      "code": "\"I'll help you respond to the customer service ticket. Let me check my memory for any previous context.\"",
      "language": "unknown"
    },
    {
      "code": "{\n  \"type\": \"tool_use\",\n  \"id\": \"toolu_01C4D5E6F7G8H9I0J1K2L3M4\",\n  \"name\": \"memory\",\n  \"input\": {\n    \"command\": \"view\",\n    \"path\": \"/memories\"\n  }\n}",
      "language": "json"
    },
    {
      "code": "{\n  \"type\": \"tool_result\",\n  \"tool_use_id\": \"toolu_01C4D5E6F7G8H9I0J1K2L3M4\",\n  \"content\": \"Here're the files and directories up to 2 levels deep in /memories, excluding hidden items and node_modules:\\n4.0K\\t/memories\\n1.5K\\t/memories/customer_service_guidelines.xml\\n2.0K\\t/memories/refund_policies.xml\"\n}",
      "language": "json"
    },
    {
      "code": "{\n  \"type\": \"tool_use\",\n  \"id\": \"toolu_01D5E6F7G8H9I0J1K2L3M4N5\",\n  \"name\": \"memory\",\n  \"input\": {\n    \"command\": \"view\",\n    \"path\": \"/memories/customer_service_guidelines.xml\"\n  }\n}",
      "language": "json"
    },
    {
      "code": "{\n  \"type\": \"tool_result\",\n  \"tool_use_id\": \"toolu_01D5E6F7G8H9I0J1K2L3M4N5\",\n  \"content\": \"Here's the content of /memories/customer_service_guidelines.xml with line numbers:\\n     1\\t<guidelines>\\n     2\\t<addressing_customers>\\n     3\\t- Always address customers by their first name\\n     4\\t- Use empathetic language\\n...\"\n}",
      "language": "json"
    },
    {
      "code": "\"Based on your customer service guidelines, I can help you craft a response. Please share the ticket details...\"",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "</CodeGroup>\n\n## Tool commands\n\nYour client-side implementation needs to handle these memory tool commands. While these specifications describe the recommended behaviors that Claude is most familiar with, you can modify your implementation and return strings as needed for your use case.\n\n### view\nShows directory contents or file contents with optional line ranges:",
      "language": "unknown"
    },
    {
      "code": "#### Return values\n\n**For directories:** Return a listing that shows files and directories with their sizes:",
      "language": "unknown"
    },
    {
      "code": "- Lists files up to 2 levels deep\n- Shows human-readable sizes (e.g., `5.5K`, `1.2M`)\n- Excludes hidden items (files starting with `.`) and `node_modules`\n- Uses tab character between size and path\n\n**For files:** Return file contents with a header and line numbers:",
      "language": "unknown"
    },
    {
      "code": "Line number formatting:\n- **Width**: 6 characters, right-aligned with space padding\n- **Separator**: Tab character between line number and content\n- **Indexing**: 1-indexed (first line is line 1)\n- **Line limit**: Files with more than 999,999 lines should return an error: `\"File {path} exceeds maximum line limit of 999,999 lines.\"`\n\n**Example output:**",
      "language": "unknown"
    },
    {
      "code": "#### Error handling\n\n- **File/directory does not exist**: `\"The path {path} does not exist. Please provide a valid path.\"`\n\n### create\nCreate a new file:",
      "language": "unknown"
    },
    {
      "code": "#### Return values\n\n- **Success**: `\"File created successfully at: {path}\"`\n\n#### Error handling\n\n- **File already exists**: `\"Error: File {path} already exists\"`\n\n### str_replace\nReplace text in a file:",
      "language": "unknown"
    },
    {
      "code": "#### Return values\n\n- **Success**: `\"The memory file has been edited.\"` followed by a snippet of the edited file with line numbers\n\n#### Error handling\n\n- **File does not exist**: `\"Error: The path {path} does not exist. Please provide a valid path.\"`\n- **Text not found**: ``\"No replacement was performed, old_str `{old_str}` did not appear verbatim in {path}.\"``\n- **Duplicate text**: When `old_str` appears multiple times, return: ``\"No replacement was performed. Multiple occurrences of old_str `{old_str}` in lines: {line_numbers}. Please ensure it is unique\"``\n\n#### Directory handling\n\nIf the path is a directory, return a \"file does not exist\" error.\n\n### insert\nInsert text at a specific line:",
      "language": "unknown"
    },
    {
      "code": "#### Return values\n\n- **Success**: `\"The file {path} has been edited.\"`\n\n#### Error handling\n\n- **File does not exist**: `\"Error: The path {path} does not exist\"`\n- **Invalid line number**: ``\"Error: Invalid `insert_line` parameter: {insert_line}. It should be within the range of lines of the file: [0, {n_lines}]\"``\n\n#### Directory handling\n\nIf the path is a directory, return a \"file does not exist\" error.\n\n### delete\nDelete a file or directory:",
      "language": "unknown"
    },
    {
      "code": "#### Return values\n\n- **Success**: `\"Successfully deleted {path}\"`\n\n#### Error handling\n\n- **File/directory does not exist**: `\"Error: The path {path} does not exist\"`\n\n#### Directory handling\n\nDeletes the directory and all its contents recursively.\n\n### rename\nRename or move a file/directory:",
      "language": "unknown"
    },
    {
      "code": "#### Return values\n\n- **Success**: `\"Successfully renamed {old_path} to {new_path}\"`\n\n#### Error handling\n\n- **Source does not exist**: `\"Error: The path {old_path} does not exist\"`\n- **Destination already exists**: Return an error (do not overwrite): `\"Error: The destination {new_path} already exists\"`\n\n#### Directory handling\n\nRenames the directory.\n\n## Prompting guidance\n\nWe automatically include this instruction to the system prompt when the memory tool is included:",
      "language": "unknown"
    },
    {
      "code": "If you observe Claude creating cluttered memory files, you can include this instruction:\n\n> Note: when editing your memory folder, always try to keep its content up-to-date, coherent and organized. You can rename or delete files that are no longer relevant. Do not create new files unless necessary.\n\nYou can also guide what Claude writes to memory, e.g., \"Only write down information relevant to \\<topic\\> in your memory system.\"\n\n## Security considerations\n\nHere are important security concerns when implementing your memory store:\n\n### Sensitive information\nClaude will usually refuse to write down sensitive information in memory files. However, you may want to implement stricter validation that strips out potentially sensitive information.\n\n### File storage size\nConsider tracking memory file sizes and preventing files from growing too large. Consider adding a maximum number of characters the memory read command can return, and let Claude paginate through contents.\n\n### Memory expiration\nConsider clearing out memory files periodically that haven't been accessed in an extended time.\n\n### Path traversal protection\n\n<Warning>\nMalicious path inputs could attempt to access files outside the `/memories` directory. Your implementation **MUST** validate all paths to prevent directory traversal attacks.\n</Warning>\n\nConsider these safeguards:\n\n- Validate that all paths start with `/memories`\n- Resolve paths to their canonical form and verify they remain within the memory directory\n- Reject paths containing sequences like `../`, `..\\\\`, or other traversal patterns\n- Watch for URL-encoded traversal sequences (`%2e%2e%2f`)\n- Use your language's built-in path security utilities (e.g., Python's `pathlib.Path.resolve()` and `relative_to()`)\n\n## Error handling\n\nThe memory tool uses similar error handling patterns to the [text editor tool](/docs/en/agents-and-tools/tool-use/text-editor-tool#handle-errors). See the individual tool command sections above for detailed error messages and behaviors. Common errors include file not found, permission errors, invalid paths, and duplicate text matches.\n\n## Using with Context Editing\n\nThe memory tool can be combined with [context editing](/docs/en/build-with-claude/context-editing), which automatically clears old tool results when conversation context grows beyond a configured threshold. This combination enables long-running agentic workflows that would otherwise exceed context limits.\n\n### How they work together\n\nWhen context editing is enabled and your conversation approaches the clearing threshold, Claude automatically receives a warning notification. This prompts Claude to preserve any important information from tool results into memory files before those results are cleared from the context window.\n\nAfter tool results are cleared, Claude can retrieve the stored information from memory files whenever needed, effectively treating memory as an extension of its working context. This allows Claude to:\n\n- Continue complex, multi-step workflows without losing critical information\n- Reference past work and decisions even after tool results are removed\n- Maintain coherent context across conversations that would exceed typical context limits\n- Build up a knowledge base over time while keeping the active context window manageable\n\n### Example workflow\n\nConsider a code refactoring project with many file operations:\n\n1. Claude makes numerous edits to files, generating many tool results\n2. As the context grows and approaches your threshold, Claude receives a warning\n3. Claude summarizes the changes made so far to a memory file (e.g., `/memories/refactoring_progress.xml`)\n4. Context editing clears the older tool results automatically\n5. Claude continues working, referencing the memory file when it needs to recall what changes were already completed\n6. The workflow can continue indefinitely, with Claude managing both active context and persistent memory\n\n### Configuration\n\nTo use both features together:\n\n<CodeGroup>",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "</CodeGroup>\n\nYou can also exclude memory tool calls from being cleared to ensure Claude always has access to recent memory operations:\n\n<CodeGroup>",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "Use cases",
      "id": "use-cases"
    },
    {
      "level": "h2",
      "text": "How it works",
      "id": "how-it-works"
    },
    {
      "level": "h3",
      "text": "Example: How memory tool calls work",
      "id": "example:-how-memory-tool-calls-work"
    },
    {
      "level": "h2",
      "text": "Supported models",
      "id": "supported-models"
    },
    {
      "level": "h2",
      "text": "Getting started",
      "id": "getting-started"
    },
    {
      "level": "h2",
      "text": "Basic usage",
      "id": "basic-usage"
    },
    {
      "level": "h2",
      "text": "Tool commands",
      "id": "tool-commands"
    },
    {
      "level": "h3",
      "text": "view",
      "id": "view"
    },
    {
      "level": "h3",
      "text": "create",
      "id": "create"
    },
    {
      "level": "h3",
      "text": "str_replace",
      "id": "str_replace"
    },
    {
      "level": "h3",
      "text": "insert",
      "id": "insert"
    },
    {
      "level": "h3",
      "text": "delete",
      "id": "delete"
    },
    {
      "level": "h3",
      "text": "rename",
      "id": "rename"
    },
    {
      "level": "h2",
      "text": "Prompting guidance",
      "id": "prompting-guidance"
    },
    {
      "level": "h2",
      "text": "Security considerations",
      "id": "security-considerations"
    },
    {
      "level": "h3",
      "text": "Sensitive information",
      "id": "sensitive-information"
    },
    {
      "level": "h3",
      "text": "File storage size",
      "id": "file-storage-size"
    },
    {
      "level": "h3",
      "text": "Memory expiration",
      "id": "memory-expiration"
    },
    {
      "level": "h3",
      "text": "Path traversal protection",
      "id": "path-traversal-protection"
    },
    {
      "level": "h2",
      "text": "Error handling",
      "id": "error-handling"
    },
    {
      "level": "h2",
      "text": "Using with Context Editing",
      "id": "using-with-context-editing"
    },
    {
      "level": "h3",
      "text": "How they work together",
      "id": "how-they-work-together"
    },
    {
      "level": "h3",
      "text": "Example workflow",
      "id": "example-workflow"
    },
    {
      "level": "h3",
      "text": "Configuration",
      "id": "configuration"
    }
  ],
  "url": "llms-txt#memory-tool",
  "links": []
}