{
  "title": "Call the model again with the same inputs up to the cache checkpoint",
  "content": "response = client.messages.create(.....)\nprint(response.usage.model_dump_json())\ntypescript TypeScript\nimport Anthropic from '@anthropic-ai/sdk';\n\nconst client = new Anthropic();\n\nconst response = await client.messages.create({\n  model: \"claude-sonnet-4-5\",\n  max_tokens: 1024,\n  system: [\n    {\n      type: \"text\",\n      text: \"You are an AI assistant tasked with analyzing literary works. Your goal is to provide insightful commentary on themes, characters, and writing style.\\n\",\n    },\n    {\n      type: \"text\",\n      text: \"<the entire contents of 'Pride and Prejudice'>\",\n      cache_control: { type: \"ephemeral\" }\n    }\n  ],\n  messages: [\n    {\n      role: \"user\",\n      content: \"Analyze the major themes in 'Pride and Prejudice'.\"\n    }\n  ]\n});\nconsole.log(response.usage);\n\n// Call the model again with the same inputs up to the cache checkpoint\nconst new_response = await client.messages.create(...)\nconsole.log(new_response.usage);\njava Java\nimport java.util.List;\n\nimport com.anthropic.client.AnthropicClient;\nimport com.anthropic.client.okhttp.AnthropicOkHttpClient;\nimport com.anthropic.models.messages.CacheControlEphemeral;\nimport com.anthropic.models.messages.Message;\nimport com.anthropic.models.messages.MessageCreateParams;\nimport com.anthropic.models.messages.Model;\nimport com.anthropic.models.messages.TextBlockParam;\n\npublic class PromptCachingExample {\n\npublic static void main(String[] args) {\n        AnthropicClient client = AnthropicOkHttpClient.fromEnv();\n\nMessageCreateParams params = MessageCreateParams.builder()\n                .model(Model.CLAUDE_OPUS_4_20250514)\n                .maxTokens(1024)\n                .systemOfTextBlockParams(List.of(\n                        TextBlockParam.builder()\n                                .text(\"You are an AI assistant tasked with analyzing literary works. Your goal is to provide insightful commentary on themes, characters, and writing style.\\n\")\n                                .build(),\n                        TextBlockParam.builder()\n                                .text(\"<the entire contents of 'Pride and Prejudice'>\")\n                                .cacheControl(CacheControlEphemeral.builder().build())\n                                .build()\n                ))\n                .addUserMessage(\"Analyze the major themes in 'Pride and Prejudice'.\")\n                .build();\n\nMessage message = client.messages().create(params);\n        System.out.println(message.usage());\n    }\n}\njson JSON\n{\"cache_creation_input_tokens\":188086,\"cache_read_input_tokens\":0,\"input_tokens\":21,\"output_tokens\":393}\n{\"cache_creation_input_tokens\":0,\"cache_read_input_tokens\":188086,\"input_tokens\":21,\"output_tokens\":393}\n\ntotal_input_tokens = cache_read_input_tokens + cache_creation_input_tokens + input_tokens\n\nRequest 1: User: \"What's the weather in Paris?\"\nResponse: [thinking_block_1] + [tool_use block 1]\n\nRequest 2:\nUser: [\"What's the weather in Paris?\"],\nAssistant: [thinking_block_1] + [tool_use block 1],\nUser: [tool_result_1, cache=True]\nResponse: [thinking_block_2] + [text block 2]",
  "code_samples": [
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "</CodeGroup>",
      "language": "unknown"
    },
    {
      "code": "In this example, the entire text of \"Pride and Prejudice\" is cached using the `cache_control` parameter. This enables reuse of this large text across multiple API calls without reprocessing it each time. Changing only the user message allows you to ask various questions about the book while utilizing the cached content, leading to faster responses and improved efficiency.\n\n---\n\n## How prompt caching works\n\nWhen you send a request with prompt caching enabled:\n\n1. The system checks if a prompt prefix, up to a specified cache breakpoint, is already cached from a recent query.\n2. If found, it uses the cached version, reducing processing time and costs.\n3. Otherwise, it processes the full prompt and caches the prefix once the response begins.\n\nThis is especially useful for:\n- Prompts with many examples\n- Large amounts of context or background information\n- Repetitive tasks with consistent instructions\n- Long multi-turn conversations\n\nBy default, the cache has a 5-minute lifetime. The cache is refreshed for no additional cost each time the cached content is used.\n\n<Note>\nIf you find that 5 minutes is too short, Anthropic also offers a 1-hour cache duration [at additional cost](#pricing).\n\nFor more information, see [1-hour cache duration](#1-hour-cache-duration).\n</Note>\n\n<Tip>\n  **Prompt caching caches the full prefix**\n\nPrompt caching references the entire prompt - `tools`, `system`, and `messages` (in that order) up to and including the block designated with `cache_control`.\n\n</Tip>\n\n---\n## Pricing\n\nPrompt caching introduces a new pricing structure. The table below shows the price per million tokens for each supported model:\n\n| Model             | Base Input Tokens | 5m Cache Writes | 1h Cache Writes | Cache Hits & Refreshes | Output Tokens |\n|-------------------|-------------------|-----------------|-----------------|----------------------|---------------|\n| Claude Opus 4.5   | $5 / MTok         | $6.25 / MTok    | $10 / MTok      | $0.50 / MTok | $25 / MTok    |\n| Claude Opus 4.1   | $15 / MTok        | $18.75 / MTok   | $30 / MTok      | $1.50 / MTok | $75 / MTok    |\n| Claude Opus 4     | $15 / MTok        | $18.75 / MTok   | $30 / MTok      | $1.50 / MTok | $75 / MTok    |\n| Claude Sonnet 4.5   | $3 / MTok         | $3.75 / MTok    | $6 / MTok       | $0.30 / MTok | $15 / MTok    |\n| Claude Sonnet 4   | $3 / MTok         | $3.75 / MTok    | $6 / MTok       | $0.30 / MTok | $15 / MTok    |\n| Claude Sonnet 3.7 ([deprecated](/docs/en/about-claude/model-deprecations)) | $3 / MTok         | $3.75 / MTok    | $6 / MTok       | $0.30 / MTok | $15 / MTok    |\n| Claude Haiku 4.5  | $1 / MTok         | $1.25 / MTok    | $2 / MTok       | $0.10 / MTok | $5 / MTok     |\n| Claude Haiku 3.5  | $0.80 / MTok      | $1 / MTok       | $1.6 / MTok     | $0.08 / MTok | $4 / MTok     |\n| Claude Opus 3 ([deprecated](/docs/en/about-claude/model-deprecations))    | $15 / MTok        | $18.75 / MTok   | $30 / MTok      | $1.50 / MTok | $75 / MTok    |\n| Claude Haiku 3    | $0.25 / MTok      | $0.30 / MTok    | $0.50 / MTok    | $0.03 / MTok | $1.25 / MTok  |\n\n<Note>\nThe table above reflects the following pricing multipliers for prompt caching:\n- 5-minute cache write tokens are 1.25 times the base input tokens price\n- 1-hour cache write tokens are 2 times the base input tokens price\n- Cache read tokens are 0.1 times the base input tokens price\n</Note>\n\n---\n## How to implement prompt caching\n\n### Supported models\n\nPrompt caching is currently supported on:\n- Claude Opus 4.5\n- Claude Opus 4.1\n- Claude Opus 4\n- Claude Sonnet 4.5\n- Claude Sonnet 4\n- Claude Sonnet 3.7 ([deprecated](/docs/en/about-claude/model-deprecations))\n- Claude Haiku 4.5\n- Claude Haiku 3.5 ([deprecated](/docs/en/about-claude/model-deprecations))\n- Claude Haiku 3\n\n### Structuring your prompt\n\nPlace static content (tool definitions, system instructions, context, examples) at the beginning of your prompt. Mark the end of the reusable content for caching using the `cache_control` parameter.\n\nCache prefixes are created in the following order: `tools`, `system`, then `messages`. This order forms a hierarchy where each level builds upon the previous ones.\n\n#### How automatic prefix checking works\n\nYou can use just one cache breakpoint at the end of your static content, and the system will automatically find the longest matching sequence of cached blocks. Understanding how this works helps you optimize your caching strategy.\n\n**Three core principles:**\n\n1. **Cache keys are cumulative**: When you explicitly cache a block with `cache_control`, the cache hash key is generated by hashing all previous blocks in the conversation sequentially. This means the cache for each block depends on all content that came before it.\n\n2. **Backward sequential checking**: The system checks for cache hits by working backwards from your explicit breakpoint, checking each previous block in reverse order. This ensures you get the longest possible cache hit.\n\n3. **20-block lookback window**: The system only checks up to 20 blocks before each explicit `cache_control` breakpoint. After checking 20 blocks without a match, it stops checking and moves to the next explicit breakpoint (if any).\n\n**Example: Understanding the lookback window**\n\nConsider a conversation with 30 content blocks where you set `cache_control` only on block 30:\n\n- **If you send block 31 with no changes to previous blocks**: The system checks block 30 (match!). You get a cache hit at block 30, and only block 31 needs processing.\n\n- **If you modify block 25 and send block 31**: The system checks backwards from block 30 → 29 → 28... → 25 (no match) → 24 (match!). Since block 24 hasn't changed, you get a cache hit at block 24, and only blocks 25-30 need reprocessing.\n\n- **If you modify block 5 and send block 31**: The system checks backwards from block 30 → 29 → 28... → 11 (check #20). After 20 checks without finding a match, it stops looking. Since block 5 is beyond the 20-block window, no cache hit occurs and all blocks need reprocessing. However, if you had set an explicit `cache_control` breakpoint on block 5, the system would continue checking from that breakpoint: block 5 (no match) → block 4 (match!). This allows a cache hit at block 4, demonstrating why you should place breakpoints before editable content.\n\n**Key takeaway**: Always set an explicit cache breakpoint at the end of your conversation to maximize your chances of cache hits. Additionally, set breakpoints just before content blocks that might be editable to ensure those sections can be cached independently.\n\n#### When to use multiple breakpoints\n\nYou can define up to 4 cache breakpoints if you want to:\n- Cache different sections that change at different frequencies (e.g., tools rarely change, but context updates daily)\n- Have more control over exactly what gets cached\n- Ensure caching for content more than 20 blocks before your final breakpoint\n- Place breakpoints before editable content to guarantee cache hits even when changes occur beyond the 20-block window\n\n<Note>\n**Important limitation**: If your prompt has more than 20 content blocks before your cache breakpoint, and you modify content earlier than those 20 blocks, you won't get a cache hit unless you add additional explicit breakpoints closer to that content.\n</Note>\n\n### Cache limitations\nThe minimum cacheable prompt length is:\n- 4096 tokens for Claude Opus 4.5\n- 1024 tokens for Claude Opus 4.1, Claude Opus 4, Claude Sonnet 4.5, Claude Sonnet 4, and Claude Sonnet 3.7 ([deprecated](/docs/en/about-claude/model-deprecations))\n- 4096 tokens for Claude Haiku 4.5\n- 2048 tokens for Claude Haiku 3.5 ([deprecated](/docs/en/about-claude/model-deprecations)) and Claude Haiku 3\n\nShorter prompts cannot be cached, even if marked with `cache_control`. Any requests to cache fewer than this number of tokens will be processed without caching. To see if a prompt was cached, see the response usage [fields](/docs/en/build-with-claude/prompt-caching#tracking-cache-performance).\n\nFor concurrent requests, note that a cache entry only becomes available after the first response begins. If you need cache hits for parallel requests, wait for the first response before sending subsequent requests.\n\nCurrently, \"ephemeral\" is the only supported cache type, which by default has a 5-minute lifetime.\n\n### Understanding cache breakpoint costs\n\n**Cache breakpoints themselves don't add any cost.** You are only charged for:\n- **Cache writes**: When new content is written to the cache (25% more than base input tokens for 5-minute TTL)\n- **Cache reads**: When cached content is used (10% of base input token price)\n- **Regular input tokens**: For any uncached content\n\nAdding more `cache_control` breakpoints doesn't increase your costs - you still pay the same amount based on what content is actually cached and read. The breakpoints simply give you control over what sections can be cached independently.\n\n### What can be cached\nMost blocks in the request can be designated for caching with `cache_control`. This includes:\n\n- Tools: Tool definitions in the `tools` array\n- System messages: Content blocks in the `system` array\n- Text messages: Content blocks in the `messages.content` array, for both user and assistant turns\n- Images & Documents: Content blocks in the `messages.content` array, in user turns\n- Tool use and tool results: Content blocks in the `messages.content` array, in both user and assistant turns\n\nEach of these elements can be marked with `cache_control` to enable caching for that portion of the request.\n\n### What cannot be cached\nWhile most request blocks can be cached, there are some exceptions:\n\n- Thinking blocks cannot be cached directly with `cache_control`. However, thinking blocks CAN be cached alongside other content when they appear in previous assistant turns. When cached this way, they DO count as input tokens when read from cache.\n- Sub-content blocks (like [citations](/docs/en/build-with-claude/citations)) themselves cannot be cached directly. Instead, cache the top-level block.\n\n    In the case of citations, the top-level document content blocks that serve as the source material for citations can be cached. This allows you to use prompt caching with citations effectively by caching the documents that citations will reference.\n- Empty text blocks cannot be cached.\n\n### What invalidates the cache\n\nModifications to cached content can invalidate some or all of the cache.\n\nAs described in [Structuring your prompt](#structuring-your-prompt), the cache follows the hierarchy: `tools` → `system` → `messages`. Changes at each level invalidate that level and all subsequent levels.\n\nThe following table shows which parts of the cache are invalidated by different types of changes. ✘ indicates that the cache is invalidated, while ✓ indicates that the cache remains valid.\n\n| What changes | Tools cache | System cache | Messages cache | Impact |\n|------------|------------------|---------------|----------------|-------------|\n| **Tool definitions** | ✘ | ✘ | ✘ | Modifying tool definitions (names, descriptions, parameters) invalidates the entire cache |\n| **Web search toggle** | ✓ | ✘ | ✘ | Enabling/disabling web search modifies the system prompt |\n| **Citations toggle** | ✓ | ✘ | ✘ | Enabling/disabling citations modifies the system prompt |\n| **Tool choice** | ✓ | ✓ | ✘ | Changes to `tool_choice` parameter only affect message blocks |\n| **Images** | ✓ | ✓ | ✘ | Adding/removing images anywhere in the prompt affects message blocks |\n| **Thinking parameters** | ✓ | ✓ | ✘ | Changes to extended thinking settings (enable/disable, budget) affect message blocks |\n| **Non-tool results passed to extended thinking requests** | ✓ | ✓ | ✘ | When non-tool results are passed in requests while extended thinking is enabled, all previously-cached thinking blocks are stripped from context, and any messages in context that follow those thinking blocks are removed from the cache. For more details, see [Caching with thinking blocks](#caching-with-thinking-blocks). |\n\n### Tracking cache performance\n\nMonitor cache performance using these API response fields, within `usage` in the response (or `message_start` event if [streaming](/docs/en/build-with-claude/streaming)):\n\n- `cache_creation_input_tokens`: Number of tokens written to the cache when creating a new entry.\n- `cache_read_input_tokens`: Number of tokens retrieved from the cache for this request.\n- `input_tokens`: Number of input tokens which were not read from or used to create a cache (i.e., tokens after the last cache breakpoint).\n\n<Note>\n**Understanding the token breakdown**\n\nThe `input_tokens` field represents only the tokens that come **after the last cache breakpoint** in your request - not all the input tokens you sent.\n\nTo calculate total input tokens:",
      "language": "unknown"
    },
    {
      "code": "**Spatial explanation:**\n- `cache_read_input_tokens` = tokens before breakpoint already cached (reads)\n- `cache_creation_input_tokens` = tokens before breakpoint being cached now (writes)\n- `input_tokens` = tokens after your last breakpoint (not eligible for cache)\n\n**Example:** If you have a request with 100,000 tokens of cached content (read from cache), 0 tokens of new content being cached, and 50 tokens in your user message (after the cache breakpoint):\n- `cache_read_input_tokens`: 100,000\n- `cache_creation_input_tokens`: 0\n- `input_tokens`: 50\n- **Total input tokens processed**: 100,050 tokens\n\nThis is important for understanding both costs and rate limits, as `input_tokens` will typically be much smaller than your total input when using caching effectively.\n</Note>\n\n### Best practices for effective caching\n\nTo optimize prompt caching performance:\n\n- Cache stable, reusable content like system instructions, background information, large contexts, or frequent tool definitions.\n- Place cached content at the prompt's beginning for best performance.\n- Use cache breakpoints strategically to separate different cacheable prefix sections.\n- Set cache breakpoints at the end of conversations and just before editable content to maximize cache hit rates, especially when working with prompts that have more than 20 content blocks.\n- Regularly analyze cache hit rates and adjust your strategy as needed.\n\n### Optimizing for different use cases\n\nTailor your prompt caching strategy to your scenario:\n\n- Conversational agents: Reduce cost and latency for extended conversations, especially those with long instructions or uploaded documents.\n- Coding assistants: Improve autocomplete and codebase Q&A by keeping relevant sections or a summarized version of the codebase in the prompt.\n- Large document processing: Incorporate complete long-form material including images in your prompt without increasing response latency.\n- Detailed instruction sets: Share extensive lists of instructions, procedures, and examples to fine-tune Claude's responses.  Developers often include an example or two in the prompt, but with prompt caching you can get even better performance by including 20+ diverse examples of high quality answers.\n- Agentic tool use: Enhance performance for scenarios involving multiple tool calls and iterative code changes, where each step typically requires a new API call.\n- Talk to books, papers, documentation, podcast transcripts, and other longform content:  Bring any knowledge base alive by embedding the entire document(s) into the prompt, and letting users ask it questions.\n\n### Troubleshooting common issues\n\nIf experiencing unexpected behavior:\n\n- Ensure cached sections are identical and marked with cache_control in the same locations across calls\n- Check that calls are made within the cache lifetime (5 minutes by default)\n- Verify that `tool_choice` and image usage remain consistent between calls\n- Validate that you are caching at least the minimum number of tokens\n- The system automatically checks for cache hits at previous content block boundaries (up to ~20 blocks before your breakpoint). For prompts with more than 20 content blocks, you may need additional `cache_control` parameters earlier in the prompt to ensure all content can be cached\n- Verify that the keys in your `tool_use` content blocks have stable ordering as some languages (e.g. Swift, Go) randomize key order during JSON conversion, breaking caches\n\n<Note>\nChanges to `tool_choice` or the presence/absence of images anywhere in the prompt will invalidate the cache, requiring a new cache entry to be created. For more details on cache invalidation, see [What invalidates the cache](#what-invalidates-the-cache).\n</Note>\n\n### Caching with thinking blocks\n\nWhen using [extended thinking](/docs/en/build-with-claude/extended-thinking) with prompt caching, thinking blocks have special behavior:\n\n**Automatic caching alongside other content**: While thinking blocks cannot be explicitly marked with `cache_control`, they get cached as part of the request content when you make subsequent API calls with tool results. This commonly happens during tool use when you pass thinking blocks back to continue the conversation.\n\n**Input token counting**: When thinking blocks are read from cache, they count as input tokens in your usage metrics. This is important for cost calculation and token budgeting.\n\n**Cache invalidation patterns**:\n- Cache remains valid when only tool results are provided as user messages\n- Cache gets invalidated when non-tool-result user content is added, causing all previous thinking blocks to be stripped\n- This caching behavior occurs even without explicit `cache_control` markers\n\nFor more details on cache invalidation, see [What invalidates the cache](#what-invalidates-the-cache).\n\n**Example with tool use**:",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "How prompt caching works",
      "id": "how-prompt-caching-works"
    },
    {
      "level": "h2",
      "text": "Pricing",
      "id": "pricing"
    },
    {
      "level": "h2",
      "text": "How to implement prompt caching",
      "id": "how-to-implement-prompt-caching"
    },
    {
      "level": "h3",
      "text": "Supported models",
      "id": "supported-models"
    },
    {
      "level": "h3",
      "text": "Structuring your prompt",
      "id": "structuring-your-prompt"
    },
    {
      "level": "h3",
      "text": "Cache limitations",
      "id": "cache-limitations"
    },
    {
      "level": "h3",
      "text": "Understanding cache breakpoint costs",
      "id": "understanding-cache-breakpoint-costs"
    },
    {
      "level": "h3",
      "text": "What can be cached",
      "id": "what-can-be-cached"
    },
    {
      "level": "h3",
      "text": "What cannot be cached",
      "id": "what-cannot-be-cached"
    },
    {
      "level": "h3",
      "text": "What invalidates the cache",
      "id": "what-invalidates-the-cache"
    },
    {
      "level": "h3",
      "text": "Tracking cache performance",
      "id": "tracking-cache-performance"
    },
    {
      "level": "h3",
      "text": "Best practices for effective caching",
      "id": "best-practices-for-effective-caching"
    },
    {
      "level": "h3",
      "text": "Optimizing for different use cases",
      "id": "optimizing-for-different-use-cases"
    },
    {
      "level": "h3",
      "text": "Troubleshooting common issues",
      "id": "troubleshooting-common-issues"
    },
    {
      "level": "h3",
      "text": "Caching with thinking blocks",
      "id": "caching-with-thinking-blocks"
    }
  ],
  "url": "llms-txt#call-the-model-again-with-the-same-inputs-up-to-the-cache-checkpoint",
  "links": []
}